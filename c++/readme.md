`int * const p = &a`  : 指针常量，指针的指向不能修改    即 `p = &b` 非法  
`const int * p = &a`  : 常量指针，指针指向的值不能修改  即 `*p = 20` 非法

内存管理
全局区 ：
全局变量  函数外定义的变量
全局常量  cosnt修饰的全局变量
静态变量  static
字符串常量 

栈区：
局部变量
局部常量 const休息的局部变量

堆区
new出来的对象

牢记几个基本概念：

指针用于接收地址；
引用是另一个变量的别名，引用的本质是指针常量 int* const a = &b；
函数接收参可以理解为一次赋值操作
局部变量的地址要谨慎访问  

构造函数规则
c++默认创建4个函数 `无参构造函数` `无参析构函数` `默认拷贝函数，对属性进行值拷贝`  `默认运算符operator = `
如果用户定义了有参构造函数，将不会有默认构造函数，但还是有默认拷贝函数  
如果定义了拷贝函数，将不会提供其他构造函数  

在作为函数参数进行值传递和作为函数返回值时，编译器会调用拷贝函数创建一个新的副本而不是原始我们操作的对象。


任何一个空对象都会占用一个字节的内存，为了区分空对象占用内存的位置。成员函数也不会占用对象的内存空间，也是独一份存储。

使用this指针需要注意，如果一个指向对象的指针为空，该指针也是能访问类的成员函数的，如果成员函数中访问了成员属性，那么就会引发访问异常。所以在使用this指针之前，最好判断一下this是否为空`if(this!=NULL)`  

继承方式极效果一览  
![image](https://user-images.githubusercontent.com/89610539/188274103-5426d520-1d48-4ba2-ad0a-eac70a75ea22.png)  
父类中所有非静态成员属性都会被子类继承，只是某些成员属性无法被访问，被编译器隐藏了。
