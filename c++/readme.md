`int * const p = &a`  : 指针常量，指针的指向不能修改    即 `p = &b` 非法  
`const int * p = &a`  : 常量指针，指针指向的值不能修改  即 `*p = 20` 非法

### 内存管理
全局区 ：
全局变量  函数外定义的变量
全局常量  cosnt修饰的全局变量
静态变量  static
字符串常量 

栈区：
局部变量
局部常量 const休息的局部变量

堆区
new出来的对象

牢记几个基本概念：

指针用于接收地址；
引用是另一个变量的别名，引用的本质是指针常量 int* const a = &b；
函数接收参可以理解为一次赋值操作
局部变量的地址要谨慎访问  

## 面向对象

构造函数规则
c++默认创建4个函数 `无参构造函数` `无参析构函数` `默认拷贝函数，对属性进行值拷贝`  `默认运算符operator = `
如果用户定义了有参构造函数，将不会有默认构造函数，但还是有默认拷贝函数  
如果定义了拷贝函数，将不会提供其他构造函数  

在作为函数参数进行值传递和作为函数返回值时，编译器会调用拷贝函数创建一个新的副本而不是原始我们操作的对象。


任何一个空对象都会占用一个字节的内存，为了区分空对象占用内存的位置。成员函数也不会占用对象的内存空间，也是独一份存储。

使用this指针需要注意，如果一个指向对象的指针为空，该指针也是能访问类的成员函数的，如果成员函数中访问了成员属性，那么就会引发访问异常。所以在使用this指针之前，最好判断一下this是否为空`if(this!=NULL)`  

### 继承
继承方式 效果一览  
![image](https://user-images.githubusercontent.com/89610539/188274103-5426d520-1d48-4ba2-ad0a-eac70a75ea22.png)  
父类中所有非静态成员属性都会被子类继承，只是某些成员属性无法被访问，被编译器隐藏了。  
继承的构造和析构顺序:  
Base 构造 -> Son 构造 -> Son 析构 -> Base析构.


### 多态

多态分为两类：  
`静态多态`：函数重载 和 运算符重载 属于静态多态，复用函数名 
`动态多态`：派生类和虚函数实现运行时多态  
静态多态和动态多态的区别：  
静态多态的函数地址早绑定————编译阶段确定函数地址  
动态多态的函数地址晚绑定————运行阶段确定函数地址  

多态的条件： 有继承关系，子类重写父类虚函数(virtual) ，`重写` 返回值，函数名，参数列表完全一致
多态使用: 父类指针或引用指向子类对象，即参数列表中为父类的指针或引用，传入子类的对象。

### 类模板

类模板的成员函数的创建是在调用时创建  
![image](https://user-images.githubusercontent.com/89610539/189520972-48966259-1918-4c3e-934b-f3b4e3d43d14.png)  
如上图所示，编译时并不知道传进来的是什么数据类型的，所以没办法下定论能否调用showPeroson1，因此只有在调用的时候才去检查。对于类模板中如果创建了静态函数，那么该静态函数
的地址也是不固定的。下图中 person类是类模板，而P是普通的类。所以可以理解为，类模板在实例化的时候相当于生成了两个不同的类。  
![image](https://user-images.githubusercontent.com/89610539/189521167-21f0a19d-f185-4cc3-93b7-6ffadc285ffc.png)  

类模板头文件和cpp文件分开编写时，在调用的时候会出现问题。一般我们是使用`#include "xxx.h"` 的形式去包含头文件和源文件。类模板的成员只有在调用的时候才会创建，所以编译的时候编译器就不会去看cpp文件。导致链接的时候就找不到。

解决办法一： 直接include cpp文件。因为在cpp文件中已经包含了头文件，这样编译器先看到成员函数的实现，再看到类的定义。
解决办法二： 将头文件和源文件内容编写到一起 构成hpp文件
关于hpp的使用 [hpp使用](https://blog.csdn.net/zhoumoon/article/details/106330506)

